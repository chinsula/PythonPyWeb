# Оглавление

* 1.Разграничение доступа
  * 1.1. Какие есть разрешения в rest_framework.permissions?
  * 1.2. Использование разрешений
    * 1.2.1 IsAuthenticated
    * 1.2.2 IsAdminUser, IsAuthenticatedOrReadOnly
    * 1.2.3 Пользовательские разрешения
  * 1.3 Создание представления на GenericApiView
* 2.Аутентификация

* 3.Деплой

* Необязательный блок

---

# 1. Разграничение доступа

Ранее доступ к API мог получить любой пользователь, да можно ограничить саму функциональность API (разрешить только get методы), допустим, что 
пользователь может только читать информацию, а не изменять её, но это будет касаться вообще всех, а не только отдельных пользователей. Поэтому
после того как мы выяснили что за пользователь пришел к нам на сервер за информацией (аутентификация), необходимо посмотреть какие есть права на данный ресурс
у этого пользователя (авторизация).

В Django разграничение доступа к ресурсам может быть достигнуто с помощью различных механизмов:

* `Authentication` (Аутентификация): Этот механизм позволяет идентифицировать пользователя. 
Django имеет встроенную поддержку различных методов аутентификации, таких как аутентификация по токену, аутентификация по сеансу и базовая аутентификация.


* `Permissions` (Разрешения): После аутентификации Django проверяет разрешения, которые определяют, 
имеет ли пользователь доступ к определенному ресурсу или действию. Разрешения могут быть глобальными или специфичными для объектов.

  > В DRF общие разрешения задаются через классовый атрибут `permission_classes` 

  > Пример (только посмотреть):

  ```python
  from rest_framework.permissions import IsAuthenticated
  from rest_framework.response import Response
  from rest_framework.views import APIView
  
  class ExampleView(APIView):
      permission_classes = [IsAuthenticated]
  
      def get(self, request):
          content = {'message': 'Только аутентифицированные пользователи могут видеть этот контент'}
          return Response(content)
  ```
  > В этом примере `IsAuthenticated` - это разрешение, которое требует, чтобы пользователь был аутентифицирован для доступа к представлению. Если пользователь не аутентифицирован, он получит ошибку HTTP 403 Forbidden.

* `View-level permissions` (Разрешения на уровне представлений): Django позволяет определить права доступа к представлениям. 
Это позволяет вам контролировать, какие пользователи или группы пользователей могут видеть или изменять данные.
  
  > Когда необходимо локализовать какие-то разрешения до отдельных пользователей или групп, то создают свой класс с разрешениями, 
  > наследующийся от `BasePermission`, где переопределяют метод `has_permission` возвращающий `True` если пользователь имеет доступ к ресурсу (представлению),
  > `False` - если нет

  > Пример (только посмотреть):

  ```python
  from rest_framework.permissions import BasePermission
  from rest_framework.response import Response
  from rest_framework.views import APIView
  
  class ExamplePermission(BasePermission):
      def has_permission(self, request, view):
          if request.user.is_superuser:
              return True
          return False
  
  class ExampleView(APIView):
      permission_classes = [ExamplePermission]
  
      def get(self, request):
          content = {'message': 'Этот контент доступен только суперпользователям'}
          return Response(content)
  ```

  > В этом примере создается пользовательское разрешение `ExamplePermission`, которое разрешает доступ только суперпользователям к представлению.

* `Object-level permissions` (Разрешения на уровне объектов): Этот механизм позволяет управлять доступом к отдельным объектам. 
Например, вы можете разрешить только владельцу объекта (или тому, кому дали доступ до объекта) просматривать или изменять его.

  > Когда необходимо локализовать какие-то разрешения до отдельных объектов (строки таблицы), то создают свой класс с разрешениями, 
  > наследующийся от `BasePermission`, где переопределяют метод `has_object_permission` возвращающий `True` если пользователь имеет доступ к просмотру или изменения ресурса (строк таблицы в БД которые создал пользователь),
  > `False` - если нет

  > Пример (только посмотреть):

  ```python
  from rest_framework.permissions import BasePermission
  from .models import YourModel
  
  class ExampleObjectPermission(BasePermission):
      def has_object_permission(self, request, view, obj):
          # Проверяем, имеет ли пользователь доступ к объекту
          return obj.owner == request.user
  
  class ExampleObjectView(APIView):
      permission_classes = [ExampleObjectPermission]
  
      def get(self, request, pk):
          obj = YourModel.objects.get(pk=pk)
          if not request.user.has_perm('view_object', obj):
              return Response({"message": "У вас нет разрешения на просмотр этого объекта"}, status=status.HTTP_403_FORBIDDEN)
          return Response({"message": "Вы имеете доступ к этому объекту"})
  ```

  > `permission_classes` проверяются до того, как будут выполняться методы `get`, `post`, ...

  > В этом примере `ExampleObjectPermission` - это объектное разрешение, которое разрешает доступ к объекту только владельцу объекта. 
Разрешение проверяет, что пользователь, делающий запрос, является владельцем объекта. Однако помимо общего объектного разрешения проверяется то,
что у пользователя есть разрешение просматривать этот контент, вспомните первую практику, где мы вручную в админ панели раздавали разрешения отдельным пользователям или 
группам пользователям на чтение (`view_object`), изменение (`change_object`), добавление (`add_object`), удаление (`delete_object`)

  ![img.png](pic/img.png)

  > `owner` - это общепринятый термин, который используется в контексте моделей данных для указания на пользователя или владельца объекта. 
Это не встроенный атрибут Django или Python, поэтому его нужно создать в вашей модели данных, если вы хотите использовать 
его для указания на владельца объекта.

Если хочется почитать как работают разграничения именно в Django,а не DRF, то можно прочитать [здесь](https://colab.research.google.com/drive/1QvHVUhoG3dZqv2ePUxnrtVStsbUSTTsb)(не является обязательным, сделано как лекция)

## 1.1 Какие есть разрешения в rest_framework.permissions?

`rest_framework.permissions` предоставляет несколько встроенных классов разрешений для обеспечения безопасности в вашем API:
Некоторые из наиболее распространенных разрешений включают:

* `IsAuthenticated`: Пользователь должен быть аутентифицирован для доступа к ресурсу.


* `IsAdminUser`: Только пользователи с административными правами могут получить доступ к ресурсу.


* `AllowAny`: Доступ к ресурсу разрешен без аутентификации.


* `IsAuthenticatedOrReadOnly`: Аутентифицированные пользователи могут выполнять любые действия, а неаутентифицированные могут только читать (GET).


* `DjangoModelPermissions`: Разрешения, основанные на правах доступа к модели Django. Разрешает доступ на основе прав доступа add, change и delete модели Django.

  > По умолчанию данное разрешение даёт полный доступ на создание, чтение, изменение и удаление объектов модели. Чтобы ограничить это, то необходимо в самой модели в 
  > метаклассе прописать атрибут permissions и перечислением возможных действий над моделью. Как пример (только посмотреть):
  
  ```python
  class MyModel(models.Model):
      name = models.CharField(max_length=100)
  
      class Meta:
          permissions = [
              ("can_view_mymodel", "Можно посмотреть"),
              ("can_edit_mymodel", "Можно изменить"),
              ("can_delete_mymodel", "Можно удалить"),
          ]
  ```  
  > В данном примере над объектами таблицы MyModel можно совершать только действия над просмотром, изменением и удалением,
  > создать объект в БД не получится. Соответственно используя `permission_classes = [DjangoModelPermissions]`, то в API 
  > будут доступны все разрешения, что есть в модели.

* `DjangoModelPermissionsOrAnonReadOnly`: Аналогично `DjangoModelPermissions`, но неавторизированные пользователи могут просматривать ресурс.


* `DjangoObjectPermissions`: Разрешения, основанные на правах доступа к объекту Django. Позволяет настраивать доступ на основе атрибутов модели Django и прав доступа пользователя.

Все эти классы вы можете указывать в классовом атрибуте `permission_classes` вашего класса представления API.

## 1.2 Использование разрешений

По умолчанию к точке доступа API может подключиться любой желающий. Проверим это выйдя из под пользователя. И проверим доступность 
ресурса как представлению, что писали самостоятельно `AuthorAPIView` используя `APIView`

http://127.0.0.1:8000/api/authors/

`AuthorGenericAPIView` используя `GenericAPIView`

http://127.0.0.1:8000/api/authors_generic/

`AuthorViewSet` используя `ModelViewSet`

http://127.0.0.1:8000/api/authors_viewset/

Тоже самое можно проверить через Postman, любой из них будет работать, так как по умолчанию Postman проверяет доступность без 
авторизации.

Но вот допустим, нам не нравится, что доступ имеют все, допустим некоторая информация конфиденциальная или имеет ценность и хочется показывать 
её только авторизированным пользователям, таким образом добавим возможность проверять разрешения.

### 1.2.1 IsAuthenticated

Во `views.py` приложения `api` добавьте `permission_classes` в ваш `AuthorAPIView` 

```python
from rest_framework import permissions

class AuthorAPIView(APIView):
    permission_classes = [permissions.IsAuthenticated]
```

Теперь проверим доступность адреса

http://127.0.0.1:8000/api/authors/

И увидим, что необходимо авторизоваться

![img_1.png](pic/img_1.png)

То же самое будет и в Postman

![img_2.png](pic/img_2.png)

Если авторизироваться, то всё будет нормально, кроме Postman, про это поговорим в главе 2, про аутентификацию.

### 1.2.2 IsAdminUser, IsAuthenticatedOrReadOnly

`IsAdminUser`, `IsAuthenticatedOrReadOnly` работают идентично `IsAuthenticated` только `IsAdminUser` проверяет, что пользователь админ,
а `IsAuthenticatedOrReadOnly` даёт доступ на чтение неавторизированным пользователям, а авторизированным всё что требуется.


### 1.2.3 Пользовательские разрешения

Создадим свой класс разрешений, чтобы учесть все эти действия и добавим этот класс в `permission_classes` класса `AuthorGenericAPIView`


```python
class CustomPermission(permissions.BasePermission):
    """
    Пользователи могут выполнять различные действия в зависимости от их роли.
    """

    def has_permission(self, request, view):
        # Разрешаем только GET запросы для неаутентифицированных пользователей
        if request.method == 'GET' and not request.user.is_authenticated:
            return True

        # Разрешаем GET и POST запросы для аутентифицированных пользователей
        if request.method in ['GET', 'POST'] and request.user.is_authenticated:
            return True

        # Разрешаем все действия для администраторов
        if request.user.is_superuser:
            return True

        # Во всех остальных случаях возвращаем False
        return False


class AuthorGenericAPIView(GenericAPIView, RetrieveModelMixin, ListModelMixin, CreateModelMixin, UpdateModelMixin,
                           DestroyModelMixin):
    queryset = Author.objects.all()
    serializer_class = AuthorModelSerializer

    # Переопределяем атрибут permission_classes для указания нашего собственного разрешения
    permission_classes = [CustomPermission]
    
    # ...
```

Неавторизированный пользователь видит только GET запрос, POST и другие запросы не сделать

http://127.0.0.1:8000/api/authors_generic/

Авторизируемся под обычным пользователем 

username: `platon27`

password: `#8X+DujR!B`

Всех доступных пользователей можете найти в файле `users.json` в корне проекта, если его там нет, то найдете его в папке `tasks/lab5`

Теперь снова зайдем на 

http://127.0.0.1:8000/api/authors_generic/

Затем на 

http://127.0.0.1:8000/api/authors_generic/3/

И увидим, что ничего кроме GET и POST метода нет доступного

![img_3.png](pic/img_3.png)

Авторизируемся под админом и увидим полный функционал над данными

![img_4.png](pic/img_4.png)


# 2. Аутентификация

Для проверки путей через Postman достаточно просто подключиться к точке доступа не требующей авторизации

![img_5.png](pic/img_5.png)

Но вот допустим для POST запроса наше представление проверяет авторизирован ли пользователь

В `Body` в `raw` задайте

```json
{
    "name": "user_abc",
    "email": "user@abc.abc"
}
```

И соответственно запрос не пропустит, так как не знает что за пользователь его задал

![img_6.png](pic/img_6.png)

Но так как Django по умолчанию поддерживает Базовую Аутентификацию, то можно параметры пользователя передать в заголовке `HTTP_AUTHORIZATION`

## 2.1 Базовая аутентификация

Это простая форма аутентификации, где пользователь должен предоставить имя пользователя и пароль при каждом запросе.

Данные для Базовой Аутентификации передаются в кодировке `base64`.

Результат данной кодировки можно без проблем получить в python для этого достаточно воспользоваться модулем `base64`

Кодируется строка вида `login:password` получим кодированное представление для админа с его 

username: `admin`

password: `123`

В `Python Console` пропишите

```python
import base64

login = 'admin'
password = '123'
# Кодируем логин и пароль в виде строковой комбинации
credentials = base64.b64encode(f'{login}:{password}'.encode('utf-8')).decode('utf-8')
print(credentials)
```

Результат получим `YWRtaW46MTIz`

![img_9.png](pic/img_9.png)

Теперь можем передать эти данные в `Headers` по ключу `Authorization` со значением `Basic YWRtaW46MTIz`, где 
`Basic` это название метода аутентификации.

![img_10.png](pic/img_10.png)

Теперь если отправить данные на сервер, то создастся новый автор, а пользователь создавший его будет админ.

![img_8.png](pic/img_8.png)


В Postman есть более удобный инструмент для кодирования в `base64`, чем ручное определение через `python`. 
Нажмите на кнопку `"Authorization"`, выберите тип `"Basic Auth"` и введите ваше имя пользователя и пароль.

![img_7.png](pic/img_7.png)

Чтобы не было конфликтов, то удалите авторизационный заголовок из `Headers`

Изменим данные отправляемые на сервер в `Body` в `raw`, чтобы был создан новый автор, а не пришла ошибка, что автор уже существует

```json
{
    "name": "user1_abc",
    "email": "user1@abc.abc"
}
```

Отправляем и получаем ответ, что пользователь создан

![img_11.png](pic/img_11.png)


Base64 - это метод кодирования, который используется для представления бинарных данных в текстовом виде. Он не является методом шифрования или хеширования, а лишь представляет данные в другом виде.

Когда вы используете базовую аутентификацию, клиент отправляет на сервер строку в формате "Имя пользователя:Пароль", закодированную в Base64. Если у разных пользователей одни и те же аутентификационные данные, то при кодировании этих данных в Base64 они будут иметь одинаковое значение.

Однако стоит отметить, что Base64 не является безопасным методом хранения аутентификационных данных, так как он не является шифрованием. Даже если два пользователя имеют одинаковые авторизационные данные, это не является уязвимостью, так как безопасность базовой аутентификации зависит от других факторов, таких как использование HTTPS для защищенной передачи данных по сети.

В целом, использование Base64 для представления авторизационных данных в базовой аутентификации безопасно, при условии, что используется HTTPS для защиты передаваемых данных. Однако стоит избегать хранения чувствительной информации в таком формате и использовать более безопасные методы аутентификации, такие как OAuth или JWT.



Базовая аутентификация, хотя и является простым и легко понятным методом, имеет несколько уязвимостей:

* `Отправка в открытом виде`: При использовании базовой аутентификации данные (имя пользователя и пароль) отправляются в открытом виде через сеть. Это означает, что злоумышленники могут перехватить эти данные и использовать их для несанкционированного доступа.

* `Отсутствие шифрования`: Поскольку данные отправляются в открытом виде, базовая аутентификация не обеспечивает шифрования. Это делает ее уязвимой к атакам перехвата данных (например, через перехват пакетов сети).

* `Хранение паролей на стороне клиента`: Поскольку данные для аутентификации отправляются с каждым запросом, клиент должен хранить имя пользователя и пароль. Это может представлять риск безопасности, если злоумышленники получат доступ к хранилищу данных клиента.

* `Базовая аутентификация безопасна только при использовании HTTPS`: Для уменьшения рисков безопасности базовая аутентификация должна использоваться только вместе с HTTPS. В противном случае данные будут отправляться в открытом виде и станут уязвимыми к перехвату.

Из-за этих уязвимостей базовая аутентификация редко используется в приложениях, где требуется высокий уровень безопасности. Вместо этого обычно используются более безопасные методы аутентификации, такие как OAuth или JSON Web Tokens (JWT), которые обеспечивают более надежный уровень безопасности.


## 2.2 Сессионная аутентификация
Django также по умолчанию поддерживает сессионную аутентификацию.

Это более удобный способ аутентификации, где пользователь вводит имя пользователя и пароль один раз, и далее сохраняется сессия, подтверждающая аутентификацию.

Сессия это идентификатор, который хранится на сервере и передаётся в специальном файле cookie

Сессия и cookie - это два способа хранения информации о состоянии пользователя на веб-сайте, но они работают немного по-разному:

* `Cookie` (куки): Это небольшие фрагменты данных, которые веб-сервер отправляет в браузер пользователя, а браузер хранит их на локальной машине пользователя. 
Cookie обычно используются для хранения информации о предпочтениях пользователя, идентификаторов сессии, состояния входа в систему и т. д. 
Когда пользователь делает запрос на веб-сайт, весь cookie, относящийся к этому домену, автоматически включается в заголовки запроса и отправляется на сервер.


* `Сессия`: Это временный способ хранения информации о состоянии пользователя на сервере. Когда пользователь входит в 
систему или начинает сессию на веб-сайте, сервер создает уникальную сессию для этого пользователя и присваивает ей идентификатор сессии.
Этот идентификатор обычно сохраняется в cookie и отправляется обратно на сервер с каждым последующим запросом. 
На сервере информация о состоянии пользователя хранится в этой сессии. По завершении сессии (например, когда пользователь 
выходит из системы или закрывает браузер), информация о сессии удаляется. В Django сессия удаляется через 14 дней или после выхода из системы. Выход из браузера не влияет на продолжительность сессии.

Postman позволяет отправить `cookies`, чтобы была возможность сделать сессионную авторизацию

Для этого необходимо сначала узнать `id` сессии, это можно узнать в БД в таблице `django_session`, последняя строка будет соответствовать 
актуальной сессии. Необходимо значение из поля `session_key`

Это же значение можно получить из браузера, перейдите по http://127.0.0.1:8000/api/authors_generic/

И вызовите консоль разработчика, чаще всего это кнопка `F12`

Далее в зависимости от браузера путь до хранения cookie может отличаться

> Для Mozilla Firefox

![img_12.png](pic/img_12.png)

> Для Google Chrome

![img_13.png](pic/img_13.png)

> Для Яндекс Браузера

![img_14.png](pic/img_14.png)

Нам будет необходимы две строки

`sessionid` и `csrftoken`

Далее переходим в Postman

В блоке `Authorization` ставим `No Auth`

![img_15.png](pic/img_15.png)


В `Headers` прописываем `X-CSRFToken` со значением взятым из `csrftoken` в `cookie`

![img_16.png](pic/img_16.png)

В Body в raw пропишем новые данные для POST запроса

```json
{
    "name": "user5_abc",
    "email": "user5@abc.abc"
}
```

И наконец перейдем в Cookies

![img_17.png](pic/img_17.png)

Пропишем доменный адрес нашего локалхоста

`http://127.0.0.1:8000`

![img_18.png](pic/img_18.png)

Затем уже добавляем куки

![img_19.png](pic/img_19.png)

Необходимо только прописать название и значение, остальные параметры не трогайте, пусть будут по умолчанию

По ключу `sessionid` вставьте свои данные из браузера и сохраните этот cookie

![img_20.png](pic/img_20.png)

Добавьте ещё cookie нажав на `+ Add Cookie`

По ключу `csrftoken` вставьте свои данные из браузера и сохраните этот cookie

![img_21.png](pic/img_21.png)

Закройте окно и выполните запрос, если всё верно, то новый автор создастся 

![img_22.png](pic/img_22.png)

Сессионная аутентификация имеет свои преимущества и недостатки:

> Преимущества сессионной аутентификации:

* `Безопасность`: Поскольку идентификатор сессии хранится на сервере, а не на клиентской стороне, сессионная аутентификация обычно считается более безопасной, чем передача пароля в открытом виде (например, с помощью базовой аутентификации).
* `Простота использования`: Для пользователя сессионная аутентификация обычно более удобна, поскольку она не требует ввода пароля каждый раз при входе на сайт или выполнении защищенных действий.
* `Гибкость`: Сессионная аутентификация позволяет реализовать различные сценарии безопасности, такие как автоматический выход из системы после определенного периода неактивности или вход в систему с помощью многофакторной аутентификации. 

> Недостатки сессионной аутентификации:

* `Нагрузка на сервер`: Поскольку информация о сессии хранится на сервере, это может привести к увеличению нагрузки на сервер, особенно при работе с большим количеством активных сессий.
* `Зависимость от cookie`: Для сессионной аутентификации часто требуется использование cookie для хранения идентификатора сессии. Это означает, что если пользователь отключил cookie в своем браузере, сессионная аутентификация может не работать должным образом.
* `Уязвимость к атакам типа session hijacking`: Если злоумышленник получит доступ к идентификатору сессии, например, через перехват сетевого трафика или атаку CSRF, он может представиться этим пользователем и получить доступ к его учетной записи.

В целом, сессионная аутентификация является распространенным и удобным способом обеспечения безопасности веб-приложений, но она также имеет свои ограничения и риски, которые необходимо учитывать при разработке приложений.

## 2.3 Авторизация через токены

Авторизация по токенам (Token-based authentication) и сессионная авторизация (Session-based authentication) - это два различных подхода к аутентификации пользователей в веб-приложениях. 

Вот основные различия между ними:

> Хранение состояния (stateless vs stateful):

* `Токен`: Авторизация по токенам является "бессостоятельной" (stateless) системой, где сервер не хранит состояние аутентификации пользователя. Каждый запрос пользователя должен содержать токен, который сервер проверяет на валидность при каждом запросе.
* `Сессия`: Сессионная авторизация является "состоятельной" (stateful) системой, где сервер хранит информацию о сеансе пользователя (например, идентификатор сессии) на сервере. После успешной аутентификации пользователю присваивается сессионный идентификатор, который используется для идентификации пользователя при последующих запросах.

> Хранение токенов (token storage):

* `Токен`: Токены обычно хранятся на клиентской стороне, например, в Local Storage или в куки-файлах. Они могут быть долговременными (долговременные токены доступа) или краткосрочными (краткосрочные токены доступа или токены обновления).
* `Сессия`: Идентификаторы сессии хранятся на сервере и могут быть связаны с куки-файлом на клиентской стороне для идентификации пользователя при последующих запросах.

> Защита от CSRF-атак (Cross-Site Request Forgery):

* `Токен`: При использовании токенов CSRF-атаки становятся менее вероятными, так как токен должен быть явно передан с клиента на сервер и проверен на каждом запросе.
* `Сессия`: В сессионной авторизации защита от CSRF обычно достигается с использованием механизмов, таких как CSRF-токены, которые встраиваются в формы.

> Масштабируемость (scalability):

* `Токен`: Авторизация по токенам обеспечивает лучшую масштабируемость, поскольку она не требует хранения состояния на сервере. Это делает ее более подходящей для распределенных систем и микросервисных архитектур.
* `Сессия`: Сессионная авторизация может столкнуться с проблемами масштабируемости при большом количестве активных сеансов, поскольку требует хранения информации о сессиях на сервере.

### 2.3.1 TokenAuthentication

Помимо базовой аутентификации и аутентификации по сессии, среди доступных методов в DRF есть аутентификация 
по токенам. 


Для этого для `AuthorGenericAPIView` в `authentication_classes` пропишем `authentication.TokenAuthentication`

Для упрощения проверок сделаем, что получить информацию могут только авторизированные пользователи 

```python
from rest_framework import authentication

class AuthorGenericAPIView(GenericAPIView, RetrieveModelMixin, ListModelMixin, CreateModelMixin, UpdateModelMixin,
                           DestroyModelMixin):
    # ...
    permission_classes = [permissions.IsAuthenticated]
    authentication_classes = [authentication.TokenAuthentication]
    # ...
```

`TokenAuthentication` - это один из методов аутентификации в DRF, который позволяет аутентифицировать пользователей с 
использованием токенов. Токены предоставляются аутентифицированным пользователям и должны быть включены в заголовок запроса 
для аутентификации.

Для полноценной работы с токенами необходимо будет произвести ряд действий (так как будет создаваться таблица для 
хранения токенов в БД)

Добавьте `'rest_framework.authtoken'` в `INSTALLED_APPS` в файле `settings.py`:

```python
INSTALLED_APPS = [
    # ...
    'rest_framework',
    'rest_framework.authtoken',
    # ...
]
```

Запустите миграцию и создание таблиц в БД

```python
python manage.py migrate
```
![img_23.png](pic/img_23.png)


Обычно происходит следующее: пользователь регистрируется, ему выдаётся токен доступа, который он использует для
доступа к API. При работе с сессиями происходит аналогично, выдаётся токен, записывается в сессию или куки, и уже
по этому токену происходит аутентификация.

Для начала токен нужно получить, это чем-то похоже на кодирование при `base64`, только используем токенизатор,
что DRF будет использовать при аутентификации.

Чтобы не писать целое представление по получению токена, его обновлению и другие моменты, то получим используем токен
вручную, для этого в `Python Console` пропишем

```python
from django.contrib.auth.models import User
from rest_framework.authtoken.models import Token

login = 'admin'

# Token от rest_framework работает с объектами модели
user = User.objects.get(username=login)
# Получение токена по объекту модели
token, created = Token.objects.get_or_create(user=user) 
print(token)  # 'c2674caef699d8f4bccfd7b8b04b297e1615cafa'
```

Теперь уже используем данный токен для доступа, так как даже простой GET требует токена доступа

![img_24.png](pic/img_24.png)

Далее в заголовках Headers пропишите ключ `Authorization` и значение `Token <number>`, где `<number>` значение токена полученного недавно.

Теперь к ресурсу возможно обратиться используя токен доступа.

![img_25.png](pic/img_25.png)

### 2.3.2 JSON Web Tokens(JWT)

`JSON Web Token(JWT)` - это компактный и самодостаточный способ представления информации между двумя сторонами в форме 
объекта в JSON-формате. JWT используется для передачи данных между клиентом и сервером в виде токена. Он может 
использоваться для аутентификации и обмена данными в безопасном формате.

#### 2.3.2.1 Теоретическая часть
JWT состоит из трех частей, разделенных точками:

1. Заголовок (Header): Заголовок содержит информацию о типе токена (JWT) и алгоритме подписи, используемом для создания 
и проверки подписи. Пример заголовка:

```python
{
  "alg": "HS256",
  "typ": "JWT"
}
```
2. Полезная нагрузка (Payload): Полезная нагрузка содержит данные (claims), которые хранятся в токене. В JWT есть три типа claims:

   * `Registered claims`: Эти claims являются стандартными и включают, например, iss (issuer), exp (expiration time), 
sub (subject), и другие.
   * `Public claims`: Эти claims определяются пользователем и/или приложением и могут использоваться для обмена 
дополнительной информацией.
   * `Private claims`: Эти claims также определяются пользователем, но они предназначены для обмена между сторонами, 
которые заранее договорились о их значении.

Пример полезной нагрузки:
```python
{
  "sub": "1234567890",
  "name": "John Doe",
  "exp": 1516239022
}
```
3. Подпись (Signature): Подпись создается путем кодирования заголовка, полезной нагрузки и секретного ключа алгоритмом, 
указанным в заголовке. Это делает JWT самодостаточным, так как сторона, получившая токен, может проверить его подлинность, 
раскодировав токен и проверив подпись.

Процесс работы JWT:

1. Пользователь входит в систему и аутентифицируется на сервере, который генерирует JWT.
2. Сервер включает в токен информацию о пользователе и другие данные, которые ему необходимы.
3. JWT отправляется обратно клиенту, который может хранить его (например, в куках или localStorage) и включать в заголовки 
запросов к серверу.
4. При каждом запросе на сервер клиент включает токен в заголовок запроса.
5. Сервер проверяет подпись токена, раскодирует полезную нагрузку и использует информацию для аутентификации пользователя 
и принятия решения о предоставлении доступа к запрошенным ресурсам.

JWT позволяет создавать безсостоятельные, расширяемые и безопасные токены, которые могут использоваться в различных контекстах, 
таких как аутентификация в API, одиночная сессия (Single Sign-On), обмен данными между сервисами и многое другое.

###### Практическая часть

Работу с токенами будем делать с помощью сторонней библиотеки `djangorestframework-simplejwt`
Ссылка на данный пакет есть в [официальной документации restframework](https://www.django-rest-framework.org/api-guide/authentication/#json-web-token-authentication) 

[Документация djangorestframework-simplejwt](https://django-rest-framework-simplejwt.readthedocs.io/en/latest/)

JWT тоже токены, но отличаются от подхода описанного в `TokenAuthentication`

Установим `djangorestframework-simplejwt`

```python
pip install djangorestframework-simplejwt
```

Регистрация в `INSTALLED_APPS` в `settings.py`

```python
INSTALLED_APPS = [
    # ...
    'rest_framework',
    'rest_framework_simplejwt',
    # ...
]
```

Для этого для `AuthorGenericAPIView` в `authentication_classes` пропишем `JWTAuthentication` из `rest_framework_simplejwt.authentication`


```python
from rest_framework_simplejwt.authentication import JWTAuthentication

class AuthorGenericAPIView(GenericAPIView, RetrieveModelMixin, ListModelMixin, CreateModelMixin, UpdateModelMixin,
                           DestroyModelMixin):
    # ...
    authentication_classes = [JWTAuthentication]
    # ...
```

Далее необходимо получить токен и с ним сформировать запрос на получение нужной информации.
Поможет получить токен обработчик `TokenObtainPairView` у `rest_framework_simplejwt.views`

Во `rest_framework_simplejwt.views` есть часть представлений, которые мы благополучно используем для своих нужд

В `urls.py` приложения `api` пропишем

```python
from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView, TokenVerifyView

urlpatterns = [
    # ...
    path('token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),  # Получение токена
    path('token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),  # Обновление токена
    path('token/verify/', TokenVerifyView.as_view(), name='token_verify'),  # Проверка токена
]
```

Теперь если попробуем получить токен, пройдя по http://127.0.0.1:8000/api/token/

То получим сообщение, что необходим POST запрос

![img_26.png](pic/img_26.png)

Сделайте POST запрос с данными 

```json
{
    "username": "admin",
    "password": "123"
}
```

Получим огромный токен доступа, так как в нем содержится вся необходимая информация (смотри теорию)

![img_27.png](pic/img_27.png)

Нам нужен токен по ключу `access`

Настало время Postman, чтобы сделать запрос с данным токеном, по умолчанию вы можете создать обычный запрос, просто в 
заголовке `Authorization` нужно будет прописать `Bearer <token>`, где `<token>` тот токен по ключу `access`

В Postman в `Authorization` выберите `Bearer Token` и вставьте туда данные полученные из `access`

![img_28.png](pic/img_28.png)

Если по каким-то причинам не получили доступа, то заново получите ключ отправив POST запрос на http://127.0.0.1:8000/api/token/

Таким образом `djangorestframework-simplejwt` и `rest_framework.authtoken` - это два разных способа аутентификации и авторизации в DRF
с использованием токенов. Они имеют несколько существенных различий:

1. Механизм аутентификации:

   * `rest_framework.authtoken` использует механизм аутентификации на основе токенов, где каждый пользователь имеет свой 
уникальный токен, который используется для аутентификации в API. Эти токены создаются и управляются на стороне сервера.

   * `djangorestframework-simplejwt` использует JWT для аутентификации. JWT - это стандартный формат токенов, который 
содержит информацию о пользователе и может быть подписан цифровой подписью. В отличие от `rest_framework.authtoken`, 
пользовательские данные хранятся внутри самого токена, и сервер не обязан хранить и управлять отдельными токенами.

 2. Хранение данных пользователя:

    * В случае `rest_framework.authtoken`, данные пользователя (например, его идентификатор) хранятся на стороне сервера, 
 и токены служат как ссылки на эти учетные записи пользователя.

    * В `djangorestframework-simplejwt`, информация о пользователе хранится внутри самого токена, и серверу не требуется 
 для проверки подлинности пользователя. Это делает JWT более масштабируемым в средах, где у вас может быть множество 
 серверов, так как он не требует обращения к серверу для проверки токена.

 3. Сложность и настройка:

    * `rest_framework.authtoken` более прост в настройке и использовании. Он предоставляет готовые представления и 
 аутентификационные классы для использования в DRF.

    * `djangorestframework-simplejwt` требует немного больше настройки, но предоставляет более гибкую и расширяемую систему 
 аутентификации с поддержкой JWT, включая возможность настройки срока действия и обновления токенов.

 4. Срок действия токена:
     Оба метода могут поддерживать срок действия токена, но в `djangorestframework-simplejwt` это реализовано более гибко 
и позволяет устанавливать срок действия как для доступа, так и для обновления токена.

 5. Производительность и безопасность:
     JWT более безопасен в том смысле, что информация в токене зашифрована и подписана, что обеспечивает целостность данных 
и защиту от подделки. Однако это также может сделать JWT более сложным для управления, если требуется много дополнительной информации о пользователе.

Выбор между `rest_framework.authtoken` и `djangorestframework-simplejwt` зависит от ваших требований и предпочтений. 
Если вам нужна быстрая и простая аутентификация с токенами, `rest_framework.authtoken` может быть хорошим выбором. 
Если вам нужна более гибкая и безопасная аутентификация с JWT, то `djangorestframework-simplejwt` может быть более подходящим вариантом.


# 3. Деплой на сервис pythonanywhere


# Практика окончена

---

# <a name="section-optional-block"></a> <u>Необязательный блок</u> (выполнение по желанию)
